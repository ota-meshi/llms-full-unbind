/**
 * vitepress-plugin-llms format tests
 *
 * Tests for the format generated by vitepress-plugin-llms: Markdown pages separated by `---`
 */

import assert from "node:assert";
import { describe, it } from "node:test";
import { unbind, unbindStream, type Page } from "../../src/index.ts";

/**
 * Helper function to create a ReadableStream from a string
 */
function stringToStream(
  str: string,
  chunkSize = 10,
): ReadableStream<Uint8Array> {
  const encoder = new TextEncoder();
  const bytes = encoder.encode(str);
  let offset = 0;

  return new ReadableStream({
    pull(controller) {
      if (offset >= bytes.length) {
        controller.close();
        return;
      }

      const chunk = bytes.slice(offset, offset + chunkSize);
      offset += chunkSize;
      controller.enqueue(chunk);
    },
  });
}

describe("unbind (vitepress-plugin-llms format)", () => {
  it("should parse markdown-separator format", () => {
    const content = `---
url: /introduction
---

# Introduction {#introduction}

Vue.js is a progressive JavaScript framework.

## Getting Started

Start building with Vue.

---
url: /components
---

# Components Basics {#components-basics}

Components are reusable Vue instances.

## Defining a Component

Here's how to define a component.

---
url: /reactivity
---

# Reactivity

Vue's reactivity system.`;

    const pages = Array.from(unbind(content));

    assert.strictEqual(pages.length, 3);
    assert.strictEqual(pages[0].title, "Introduction");
    assert.strictEqual(pages[1].title, "Components Basics");
    assert.strictEqual(pages[2].title, "Reactivity");
    assert.ok(pages[0].content.includes("Vue.js is a progressive"));
    assert.ok(pages[1].content.includes("Components are reusable"));
  });

  it("should extract URL metadata from content", () => {
    const content = `---
url: /guide/essentials/template-syntax.md
---

# Template Syntax

Some content here.

---
url: /guide/essentials/computed-properties
---

# Computed Properties

More content.`;

    const pages = Array.from(unbind(content));

    assert.strictEqual(pages.length, 2);
    assert.strictEqual(pages[0].title, "Template Syntax");
    assert.deepStrictEqual(pages[0].metadata, {
      url: "/guide/essentials/template-syntax.md",
    });
    assert.deepStrictEqual(pages[1].metadata, {
      url: "/guide/essentials/computed-properties",
    });
  });

  it("should handle content without H1 headers", () => {
    const content = `---
url: /first
---

Some content without header

---
url: /second
---

## Only H2 Header

Content with only H2.`;

    const pages = Array.from(unbind(content));

    assert.strictEqual(pages.length, 2);
    assert.strictEqual(pages[0].title, null);
    assert.strictEqual(pages[1].title, null);
    assert.ok(pages[0].content.includes("Some content without header"));
  });

  it("should handle H1 with anchor tags", () => {
    const content = `---
url: /options
---

# Options API {#options-api}

The Options API.

---
url: /composition
---

# Composition API {#composition-api}

The Composition API.`;

    const pages = Array.from(unbind(content));

    assert.strictEqual(pages.length, 2);
    assert.strictEqual(pages[0].title, "Options API");
    assert.strictEqual(pages[1].title, "Composition API");
  });

  it("should handle empty sections", () => {
    const content = `---
url: /first
---

# First Section

Content here.

---
url: /empty
---

---
url: /third
---

# Third Section

More content.`;

    const pages = Array.from(unbind(content));

    // Empty sections are also returned as pages
    assert.strictEqual(pages.length, 3);
    assert.strictEqual(pages[0].title, "First Section");
    assert.strictEqual(pages[1].title, null);
    assert.strictEqual(pages[2].title, "Third Section");
  });
});

describe("unbindStream (vitepress-plugin-llms format)", () => {
  it("should stream parse VueJS format", async () => {
    const content = `---
url: /first
---

# First Page {#first}

Content of first page.

---
url: /second
---

# Second Page {#second}

Content of second page.`;

    const pages: Page[] = [];

    for await (const page of unbindStream(stringToStream(content))) {
      pages.push(page);
    }

    assert.strictEqual(pages.length, 2);
    assert.strictEqual(pages[0].title, "First Page");
    assert.strictEqual(pages[1].title, "Second Page");
  });

  it("should produce same results as unbind for VueJS format", async () => {
    const content = `---
url: /first
---

# Title 1

Content 1.

---
url: /second
---

# Title 2

Content 2.

---
url: /third
---

# Title 3

Content 3.`;

    const syncPages = Array.from(unbind(content));
    const streamPages: Page[] = [];

    for await (const page of unbindStream(stringToStream(content))) {
      streamPages.push(page);
    }

    assert.strictEqual(syncPages.length, streamPages.length);
    for (let i = 0; i < syncPages.length; i++) {
      assert.strictEqual(syncPages[i].title, streamPages[i].title);
      assert.strictEqual(syncPages[i].content, streamPages[i].content);
      assert.deepStrictEqual(syncPages[i].metadata, streamPages[i].metadata);
    }
  });

  it("should handle small chunks for VueJS format", async () => {
    const content = `---
url: /first
---

# Small Chunks Test

Testing small chunks.

---
url: /second
---

# Another Section

More content.`;

    const pages: Page[] = [];

    // Use very small chunk size (1 byte)
    for await (const page of unbindStream(stringToStream(content, 1))) {
      pages.push(page);
    }

    assert.strictEqual(pages.length, 2);
    assert.strictEqual(pages[0].title, "Small Chunks Test");
    assert.strictEqual(pages[1].title, "Another Section");
  });
});
