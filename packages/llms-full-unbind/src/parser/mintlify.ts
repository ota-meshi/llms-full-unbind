/**
 * Mintlify format parser
 *
 * Parses the format generated by [Mintlify](https://www.mintlify.com/docs/ai/llmstxt).
 * Each page starts with a markdown header followed by a `Source: URL` line.
 * Used by projects like [modelcontextprotocol.io](https://modelcontextprotocol.io/llms-full.txt)
 * and [bun.sh](https://bun.sh/llms-full.txt).
 */

import { extractHeaderTitle } from "../utils/extract-header-title.ts";
import type { Page, StreamingParser } from "../types.ts";
import { iterateMarkdownLinesWithoutCodeBlocks } from "../utils/iterate-md-lines.ts";

type HeaderBlock = {
  startLine: number;
  endLine: number;
  title: string;
  source: string;
};

/**
 * Streaming parser for mintlify format
 */
export class MintlifyStreamingParser implements StreamingParser {
  /**
   * Detect if the content matches Mintlify format
   * @param lines - Array of lines to check
   * @returns "certain" if confident match, "maybe" if possible match, "no" if no match
   */
  public static detect(lines: string[]): "certain" | "maybe" | "no" {
    const contentIndex = lines.findIndex((line) => line.trim());
    if (contentIndex === -1) return "no";
    let blockFound = false;
    for (const { index } of iterateMarkdownLinesWithoutCodeBlocks(lines, {
      startIndex: contentIndex,
    })) {
      const block = detectHeaderBlock(lines, index);
      if (!block) continue;
      blockFound = true;
      if (index === contentIndex) continue;
      return "certain";
    }
    return blockFound ? "maybe" : "no";
  }

  private readonly bufferLines: string[] = [];

  /**
   * Process final content in buffer
   */
  public *flush(): Generator<Page> {
    yield* extractPages(this.bufferLines);
    this.bufferLines.length = 0;
  }

  /**
   * Append line to the buffer
   */
  public appendLine(line: string): Generator<Page> {
    this.bufferLines.push(line);
    return this.processBuffer();
  }

  /**
   * Process the buffer and return complete pages
   */
  private *processBuffer(): Generator<Page> {
    const separator = findSeparatorHeaderBlock(this.bufferLines);
    if (!separator) return;

    // Extract lines up to the last separator
    const lines = this.bufferLines.splice(0, separator.startLine);
    yield* extractPages(lines);
  }
}

/**
 * Find the first header block that acts as a page separator
 *
 * Searches forwards to find a header block that has non-empty content before it.
 */
function findSeparatorHeaderBlock(lines: string[]): HeaderBlock | null {
  const contentIndex = lines.findIndex((line) => line.trim());
  if (contentIndex === -1) {
    // All lines are empty
    return null;
  }
  for (const { index } of iterateMarkdownLinesWithoutCodeBlocks(lines, {
    startIndex: contentIndex,
  })) {
    if (index === contentIndex) continue;
    const block = detectHeaderBlock(lines, index);
    if (!block) continue;
    return { startLine: index, ...block };
  }
  return null;
}

/**
 * Detect if a header block starts at the given index
 *
 * Checks for the pattern:
 *
 * ```
 * # Header Title
 * Source: /path
 * ```
 *
 * @returns Block info if found, null otherwise
 */
function detectHeaderBlock(
  lines: string[],
  index: number,
): Omit<HeaderBlock, "startLine"> | null {
  const line = lines[index].trimEnd();
  const title = extractHeaderTitle(line);
  if (title == null) return null;
  for (let nextIndex = index + 1; nextIndex < lines.length; nextIndex++) {
    const nextLine = lines[nextIndex];
    if (nextLine.startsWith("Source:")) {
      const source = nextLine.slice(7).trim();
      return { endLine: nextIndex, title, source };
    }
    if (nextLine.trim()) return null;
  }
  return null;
}

/**
 * Extract pages from lines
 */
function* extractPages(lines: string[]): Generator<Page> {
  const separator = findSeparatorHeaderBlock(lines);

  const contents: string[] = separator
    ? lines.slice(0, separator.startLine)
    : [...lines];

  // Remove starting empty lines
  while (contents.length > 0 && !contents[0].trim()) {
    contents.shift();
  }
  if (contents.length === 0) return;

  const header = detectHeaderBlock(contents, 0);

  yield {
    title: header?.title ?? null,
    content: contents.join("\n").trim(),
    metadata: header ? { source: header.source } : {},
  };

  if (separator && lines.length > separator.endLine + 1) {
    yield* extractPages(lines.slice(separator.endLine + 1));
  }
}
