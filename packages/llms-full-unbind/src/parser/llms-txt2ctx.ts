/**
 * llms_txt2ctx format parser
 *
 * Parses the llms_txt2ctx style format: `<doc title="..." desc="...">content</doc>`
 * Generated by the `llms_txt2ctx` CLI from the llms-txt package (https://github.com/AnswerDotAI/llms-txt).
 * Used by fastht.ml and similar projects.
 */

import type { Page, StreamingParser } from "../types.ts";

/**
 * Parse metadata from the content if present
 */
function parseMetadata(
  _content: string,
  desc?: string,
): Record<string, unknown> | undefined {
  const metadata: Record<string, unknown> = {};

  if (desc) {
    metadata.description = desc;
  }

  return Object.keys(metadata).length > 0 ? metadata : undefined;
}

/**
 * Parse a doc opening tag and extract attributes
 */
function parseDocTagAttributes(
  tag: string,
): { title: string; desc?: string } | null {
  const titleMatch = /title="([^"]*)"/.exec(tag);
  const descMatch = /desc="([^"]*)"/.exec(tag);

  if (!titleMatch) {
    return null;
  }

  return {
    title: titleMatch[1],
    desc: descMatch?.[1],
  };
}

/**
 * State machine states for streaming parser
 */
const PARSE_STATE = {
  LOOKING_FOR_DOC_START: 0,
  READING_DOC_TAG: 1,
  READING_CONTENT: 2,
} as const;
type ParseState = (typeof PARSE_STATE)[keyof typeof PARSE_STATE];

/**
 * Streaming parser for llms_txt2ctx format
 */
export class LlmsTxt2ctxStreamingParser implements StreamingParser {
  /**
   * Detect if the content matches llms_txt2ctx format
   */
  public static detect(lines: string[]): "certain" | "maybe" | "no" {
    const content = lines.join("\n");
    return /<doc\s+title="/.test(content) ? "certain" : "no";
  }

  private buffer = "";

  private state: ParseState = PARSE_STATE.LOOKING_FOR_DOC_START;

  private currentTag = "";

  private tagDepth = 0;

  /**
   * Process final content in buffer
   */
  public *flush(): Generator<Page> {
    // Process any remaining buffer content
    yield* this.processBuffer();
  }

  /**
   * Append line to the buffer
   */
  public appendLine(line: string): Generator<Page> {
    this.buffer += `${line}\n`;
    return this.processBuffer();
  }

  /**
   * Process the buffer and return complete pages
   */
  private *processBuffer(): Generator<Page> {
    while (this.buffer.length > 0) {
      if (this.state === PARSE_STATE.LOOKING_FOR_DOC_START) {
        // Look for <doc start
        const docStartIndex = this.buffer.indexOf("<doc");
        if (docStartIndex === -1) {
          // No doc tag found, but keep potential partial tag at end
          if (
            this.buffer.endsWith("<") ||
            this.buffer.endsWith("<d") ||
            this.buffer.endsWith("<do")
          ) {
            break;
          }
          this.buffer = "";
          break;
        }

        // Move to the doc tag start
        this.buffer = this.buffer.slice(docStartIndex);
        this.state = PARSE_STATE.READING_DOC_TAG;
        this.currentTag = "";
        this.tagDepth = 0;
      }

      if (this.state === PARSE_STATE.READING_DOC_TAG) {
        // Find the end of the opening tag
        const tagEndIndex = this.buffer.indexOf(">");
        if (tagEndIndex === -1) {
          // Tag not complete yet
          break;
        }

        this.currentTag = this.buffer.slice(0, tagEndIndex + 1);
        this.buffer = this.buffer.slice(tagEndIndex + 1);
        this.state = PARSE_STATE.READING_CONTENT;
        this.tagDepth = 1;
      }

      if (this.state === PARSE_STATE.READING_CONTENT) {
        // Look for closing </doc> tag, handling nested tags
        let searchPos = 0;
        let foundEnd = false;

        while (searchPos < this.buffer.length) {
          const nextOpenDoc = this.buffer.indexOf("<doc", searchPos);
          const nextCloseDoc = this.buffer.indexOf("</doc>", searchPos);

          if (nextCloseDoc === -1) {
            // No closing tag found yet
            break;
          }

          if (nextOpenDoc !== -1 && nextOpenDoc < nextCloseDoc) {
            // Found nested <doc before </doc>
            // Check if it's a complete opening tag
            const openTagEnd = this.buffer.indexOf(">", nextOpenDoc);
            if (openTagEnd !== -1 && openTagEnd < nextCloseDoc) {
              this.tagDepth++;
              searchPos = openTagEnd + 1;
              continue;
            }
          }

          // Found </doc>
          this.tagDepth--;
          if (this.tagDepth === 0) {
            // This is our closing tag
            const currentContent = this.buffer.slice(0, nextCloseDoc);
            this.buffer = this.buffer.slice(nextCloseDoc + "</doc>".length);

            const parsed = parseDocTagAttributes(this.currentTag);
            if (parsed) {
              const metadata = parseMetadata(currentContent, parsed.desc);
              yield {
                title: parsed.title,
                content: currentContent.trim(),
                metadata: metadata ?? {},
              };
            }

            this.state = PARSE_STATE.LOOKING_FOR_DOC_START;
            foundEnd = true;
            break;
          }
          searchPos = nextCloseDoc + "</doc>".length;
        }

        if (!foundEnd) {
          // Need more data
          break;
        }
      }
    }
  }
}
