/**
 * vitepress-plugin-llms format parser
 *
 * Parses the format generated by vitepress-plugin-llms: Markdown pages separated by frontmatter-like sections.
 * Used by projects using VitePress such as [vuejs.org](https://vuejs.org/llms-full.txt),
 * [vitejs.dev](https://vitejs.dev/llms-full.txt), and [vitepress.dev](https://vitepress.dev/llms-full.txt).
 *
 * Pages are separated by a block containing frontmatter metadata:
 * ```
 * ---
 * url: /optional/metadata.md
 * ---
 * ```
 */

import type { Page, StreamingParser } from "../types.ts";
import { iterateMarkdownLinesWithoutCodeBlocks } from "../utils/iterate-md-lines.ts";

/**
 * Frontmatter block info (3 lines: ---\nurl: /path\n---)
 */
type FrontmatterBlock = {
  startLine: number;
  endLine: number;
  url: string;
};

const RE_URL_PREFIX_LINE = /^\s*url:\s*/v;

/**
 * Streaming parser for vitepress-plugin-llms format
 */
export class VitepressPluginLlmsStreamingParser implements StreamingParser {
  private readonly bufferLines: string[] = [];

  /**
   * Detect if the current lines match the vitepress-plugin-llms format
   * @param lines - Array of lines to check
   * @returns "certain" if confident match, "maybe" if possible match, "no" if no match
   */
  public static detect(lines: string[]): "certain" | "maybe" | "no" {
    const contentIndex = lines.findIndex((line) => line.trim());
    if (contentIndex === -1) return "no";
    let frontmatterFound = false;
    for (const { index } of iterateMarkdownLinesWithoutCodeBlocks(lines, {
      startIndex: contentIndex,
    })) {
      const frontmatter = detectFrontmatterBlock(lines, index);
      if (!frontmatter) continue;
      frontmatterFound = true;
      if (index === contentIndex) continue;
      return "certain";
    }
    return frontmatterFound ? "maybe" : "no";
  }

  /**
   * Process final content in buffer
   */
  public *flush(): Generator<Page> {
    yield* extractPages(this.bufferLines);
    this.bufferLines.length = 0;
  }

  /**
   * Append line to the buffer
   */
  public appendLine(line: string): Generator<Page> {
    this.bufferLines.push(line);
    return this.processBuffer();
  }

  /**
   * Process the buffer and return complete pages
   */
  private *processBuffer(): Generator<Page> {
    const separator = findSeparatorFrontmatter(this.bufferLines);
    if (!separator) return;

    // Extract lines up to the last separator
    const lines = this.bufferLines.splice(0, separator.startLine);
    yield* extractPages(lines);
  }
}

/**
 * Find the first frontmatter block that acts as a page separator
 *
 * Searches forwards to find a frontmatter block that has non-empty content before it.
 */
function findSeparatorFrontmatter(lines: string[]): FrontmatterBlock | null {
  const contentIndex = lines.findIndex((line) => line.trim());
  if (contentIndex === -1) {
    // All lines are empty
    return null;
  }
  for (const { index } of iterateMarkdownLinesWithoutCodeBlocks(lines, {
    startIndex: contentIndex,
  })) {
    if (index === contentIndex) continue;
    const frontmatter = detectFrontmatterBlock(lines, index);
    if (!frontmatter) continue;
    return { startLine: index, ...frontmatter };
  }
  return null;
}

/**
 * Detect if a frontmatter block starts at the given index
 *
 * Checks for the pattern:
 * ---
 * url: /path
 * ---
 *
 * @returns Block info (endLine and url) if found, null otherwise
 */
function detectFrontmatterBlock(
  lines: string[],
  index: number,
): Omit<FrontmatterBlock, "startLine"> | null {
  const line = lines[index].trimEnd();
  if (line !== "---") return null;
  const nextLine = lines[index + 1] ?? "";
  const nextNextLine = lines[index + 2] ?? "";
  const matchUrl = RE_URL_PREFIX_LINE.exec(nextLine);
  if (!matchUrl) return null;
  const url = nextLine.slice(matchUrl[0].length).trim();
  if (nextNextLine !== "---") return null;

  return { endLine: index + 2, url };
}

/**
 * Extract pages from lines
 */
function* extractPages(lines: string[]): Generator<Page> {
  const separator = findSeparatorFrontmatter(lines);

  const contents: string[] = separator
    ? lines.slice(0, separator.startLine)
    : [...lines];

  // Remove starting empty lines
  while (contents.length > 0 && !contents[0].trim()) {
    contents.shift();
  }
  if (contents.length === 0) return;

  const frontmatter = detectFrontmatterBlock(contents, 0);
  if (frontmatter) {
    contents.splice(0, frontmatter.endLine + 1);
  }

  // Remove starting empty lines
  while (contents.length > 0 && !contents[0].trim()) {
    contents.shift();
  }

  yield {
    title: null,
    content: contents.join("\n").trim(),
    metadata: frontmatter ? { url: frontmatter.url } : {},
  };

  if (separator && lines.length > separator.endLine + 1) {
    yield* extractPages(lines.slice(separator.endLine + 1));
  }
}
