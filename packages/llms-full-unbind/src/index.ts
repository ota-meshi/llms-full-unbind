/**
 * llms-full-unbind
 *
 * Unbind `llms-full.txt` into individual pages programmatically.
 * A specialized parser designed to extract pages from the monolithic `llms-full.txt` format.
 *
 * Supports multiple formats:
 * - llms_txt2ctx format: `<doc title="..." desc="...">content</doc>` (generated by llms_txt2ctx CLI)
 * - vitepress-plugin-llms format: Markdown pages separated by `---` (generated by vitepress-plugin-llms)
 * - mintlify format: Markdown pages with `# Title` followed by `Source: URL` (generated by Mintlify)
 */

// Re-export types
export type { Page, StreamingParser } from "./types.ts";

// Import types and parsers
import type { Page, StreamingParser } from "./types.ts";
import { stringToLines, toLines } from "./utils/to-line.ts";
import { LlmsTxt2ctxStreamingParser } from "./parser/llms-txt2ctx.ts";
import { VitepressPluginLlmsStreamingParser } from "./parser/vitepress-plugin-llms.ts";
import { MintlifyStreamingParser } from "./parser/mintlify.ts";
import { H1StreamingParser } from "./parser/h1.ts";

/**
 * Parser state for tracking format detection and buffering
 */
type ParserState = {
  parser: StreamingParser | null;
  bufferLines: string[];
};

type ParserDetector = (detectKind: "certain" | "maybe" | "no") => boolean;

const intermediateDetector: ParserDetector = (detectKind) =>
  detectKind === "certain";
const finalDetector: ParserDetector = (detectKind) =>
  detectKind === "certain" || detectKind === "maybe";

/**
 * Detect format and instantiate appropriate parser
 *
 * Tries to detect the format by checking buffer content against each parser's detection logic.
 * Returns the first matching parser or null if no format is detected yet.
 */
function detectParser(
  bufferLines: string[],
  checkDetect: (detectKind: "certain" | "maybe" | "no") => boolean,
): StreamingParser | null {
  if (checkDetect(VitepressPluginLlmsStreamingParser.detect(bufferLines))) {
    return new VitepressPluginLlmsStreamingParser();
  }
  if (checkDetect(MintlifyStreamingParser.detect(bufferLines))) {
    return new MintlifyStreamingParser();
  }
  if (checkDetect(LlmsTxt2ctxStreamingParser.detect(bufferLines))) {
    return new LlmsTxt2ctxStreamingParser();
  }
  if (checkDetect(H1StreamingParser.detect(bufferLines))) {
    return new H1StreamingParser();
  }
  return null;
}

/**
 * Process a single line and yield any completed pages
 *
 * If parser is not yet detected, buffers the line and attempts detection.
 * Once detected, feeds buffered lines to the parser and processes subsequent lines.
 */
function* processLine(line: string, state: ParserState) {
  if (state.parser == null) {
    state.bufferLines.push(line);
    state.parser = detectParser(state.bufferLines, intermediateDetector);

    if (state.parser) {
      // Feed buffered lines to the parser
      for (const bufferLine of state.bufferLines) {
        yield* state.parser.appendLine(bufferLine);
      }
      // eslint-disable-next-line require-atomic-updates -- OK
      state.bufferLines.length = 0;
    }
  } else {
    yield* state.parser.appendLine(line);
  }
}

/**
 * Finalize parser state and yield any remaining pages
 */
function* postprocessParserState(state: ParserState) {
  if (state.parser == null) {
    state.parser = detectParser(state.bufferLines, finalDetector);
    if (state.parser) {
      for (const bufferLine of state.bufferLines) {
        yield* state.parser.appendLine(bufferLine);
      }
    }
  }

  if (state.parser?.flush) {
    yield* state.parser.flush();
  }
}

/**
 * Process synchronous iterable of lines and yield pages
 */
function* processLines(lines: Iterable<string>) {
  const state: ParserState = {
    parser: null,
    bufferLines: [],
  };

  for (const line of lines) {
    yield* processLine(line, state);
  }
  yield* postprocessParserState(state);
}

/**
 * Process asynchronous iterable of lines and yield pages
 */
async function* processLinesAsync(lines: AsyncIterable<string>) {
  const state: ParserState = {
    parser: null,
    bufferLines: [],
  };

  for await (const line of lines) {
    yield* processLine(line, state);
  }
  yield* postprocessParserState(state);
}

/**
 * Parses the entire string synchronously and returns an iterable of pages.
 *
 * Automatically detects the format of the content:
 * - llms_txt2ctx format: `<doc title="..." desc="...">content</doc>` (generated by llms_txt2ctx CLI)
 * - vitepress-plugin-llms format: Markdown pages separated by `---` (generated by vitepress-plugin-llms)
 * - mintlify format: Markdown pages with `# Title` followed by `Source: URL` (generated by Mintlify)
 *
 * @param content - The full content of llms-full.txt
 * @returns An iterable of Page objects
 *
 * @example
 * ```typescript
 * import { unbind } from "llms-full-unbind";
 *
 * const response = await fetch("https://example.com/llms-full.txt");
 * const text = await response.text();
 * const pages = Array.from(unbind(text));
 *
 * console.log(`Extracted ${pages.length} pages.`);
 * ```
 */
export function* unbind(content: string): Iterable<Page> {
  yield* processLines(stringToLines(content));
}

/**
 * Accepts a standard Web `ReadableStream` (returned by `fetch`) or any Async Iterable.
 * Yields pages as soon as they are parsed.
 *
 * Automatically detects the format of the content:
 * - llms_txt2ctx format: `<doc title="..." desc="...">content</doc>` (generated by llms_txt2ctx CLI)
 * - vitepress-plugin-llms format: Markdown pages separated by `---` (generated by vitepress-plugin-llms)
 * - mintlify format: Markdown pages with `# Title` followed by `Source: URL` (generated by Mintlify)
 *
 * @param stream - A Web ReadableStream or AsyncIterable providing the content
 * @returns An AsyncIterable of Page objects
 *
 * @example
 * ```typescript
 * import { unbindStream } from "llms-full-unbind";
 *
 * const response = await fetch("https://example.com/llms-full.txt");
 *
 * if (!response.body) {
 *   throw new Error("Response body is empty");
 * }
 *
 * for await (const page of unbindStream(response.body)) {
 *   console.log(`Processed: ${page.title}`);
 * }
 * ```
 */
export async function* unbindStream(
  stream: ReadableStream<Uint8Array> | AsyncIterable<Uint8Array | string>,
): AsyncIterable<Page> {
  yield* processLinesAsync(toLines(stream));
}
