/**
 * llms-full-unbind
 *
 * Unbind `llms-full.txt` into individual pages programmatically.
 * A specialized parser designed to extract pages from the monolithic `llms-full.txt` format.
 *
 * Supports multiple formats:
 * - llms_txt2ctx format: `<doc title="..." desc="...">content</doc>` (generated by llms_txt2ctx CLI)
 * - vitepress-plugin-llms format: Markdown pages separated by `---` (generated by vitepress-plugin-llms)
 * - mintlify format: Markdown pages with `# Title` followed by `Source: URL` (generated by Mintlify)
 */

// Re-export types
export type { Page, StreamingParser } from "./types.ts";

// Import types and parsers
import type { Page, StreamingParser } from "./types.ts";
import { stringToLines, toLines } from "./utils/to-line.ts";
import { VitepressPluginLlmsStreamingParser } from "./parser/vitepress-plugin-llms.ts";
import { MintlifyStreamingParser } from "./parser/mintlify.ts";
import { H1StreamingParser } from "./parser/h1.ts";
import { DocTagStreamingParser } from "./parser/doc-tag.ts";
import { PageTagStreamingParser } from "./parser/page-tag.ts";
import { extractH1Title } from "./utils/extract-header-title.ts";

/**
 * Parser state for tracking format detection and buffering
 */
type ParserState = {
  parser: StreamingParser | null;
  bufferLines: string[];
};

type ParserDetector = (detectKind: "certain" | "maybe" | "no") => boolean;

const intermediateDetector: ParserDetector = (detectKind) =>
  detectKind === "certain";
const finalDetector: ParserDetector = (detectKind) =>
  detectKind === "certain" || detectKind === "maybe";

/**
 * Detect format and instantiate appropriate parser
 *
 * Tries to detect the format by checking buffer content against each parser's detection logic.
 * Parsers are checked in priority order:
 * 1. VitePress plugin format (frontmatter-based)
 * 2. Mintlify format (header + source URL)
 * 3. Doc tag format (<doc> tags)
 * 4. Page tag format (<page> tags)
 * 5. H1 header format (fallback for generic markdown)
 *
 * @param bufferLines - Lines to check for format detection
 * @param checkDetect - Filter function to determine which detection results to accept
 * @returns Instantiated parser or null if no format detected yet
 */
function detectParser(
  bufferLines: string[],
  checkDetect: (detectKind: "certain" | "maybe" | "no") => boolean,
): StreamingParser | null {
  if (checkDetect(VitepressPluginLlmsStreamingParser.detect(bufferLines))) {
    return new VitepressPluginLlmsStreamingParser();
  }
  if (checkDetect(MintlifyStreamingParser.detect(bufferLines))) {
    return new MintlifyStreamingParser();
  }
  if (checkDetect(DocTagStreamingParser.detect(bufferLines))) {
    return new DocTagStreamingParser();
  }
  if (checkDetect(PageTagStreamingParser.detect(bufferLines))) {
    return new PageTagStreamingParser();
  }
  if (checkDetect(H1StreamingParser.detect(bufferLines))) {
    return new H1StreamingParser();
  }
  return null;
}

/**
 * Process a single line and yield any completed pages
 *
 * If parser is not yet detected:
 * - Buffers the line and attempts to detect the format using only "certain" matches
 * - Once detected, feeds all buffered lines to the detected parser
 * Once parser is detected:
 * - Appends the line directly to the parser
 *
 * @param line - Line to process
 * @param state - Parser state including parser instance and buffer
 */
function* processLine(line: string, state: ParserState) {
  if (state.parser == null) {
    state.bufferLines.push(line);
    state.parser = detectParser(state.bufferLines, intermediateDetector);

    if (state.parser) {
      // Feed buffered lines to the parser
      for (const bufferLine of state.bufferLines) {
        yield* state.parser.appendLine(bufferLine);
      }
      // eslint-disable-next-line require-atomic-updates -- OK
      state.bufferLines.length = 0;
    }
  } else {
    yield* state.parser.appendLine(line);
  }
}

/**
 * Finalize parser state and yield any remaining pages
 *
 * If parser hasn't been detected yet, uses "maybe" matches as fallback.
 * Flushes any buffered content from the parser.
 */
function* postprocessParserState(state: ParserState) {
  if (state.parser == null) {
    state.parser = detectParser(state.bufferLines, finalDetector);
    if (state.parser) {
      for (const bufferLine of state.bufferLines) {
        yield* state.parser.appendLine(bufferLine);
      }
    }
  }

  if (state.parser?.flush) {
    yield* state.parser.flush();
  }
}

/**
 * Process synchronous iterable of lines and yield completed pages
 * @param lines - Synchronous iterable of lines
 */
function* processLines(lines: Iterable<string>) {
  const state: ParserState = {
    parser: null,
    bufferLines: [],
  };

  for (const line of lines) {
    yield* processLine(line, state).map(adjustPage);
  }
  yield* postprocessParserState(state).map(adjustPage);
}

/**
 * Process asynchronous iterable of lines and yield completed pages
 * @param lines - Asynchronous iterable of lines
 */
async function* processLinesAsync(lines: AsyncIterable<string>) {
  const state: ParserState = {
    parser: null,
    bufferLines: [],
  };

  for await (const line of lines) {
    yield* processLine(line, state).map(adjustPage);
  }
  yield* postprocessParserState(state).map(adjustPage);
}

/**
 * Adjust page by inferring title if missing
 * @param page - Page to adjust
 * @returns Adjusted page with inferred title if necessary
 */
function adjustPage(page: Page): Page {
  return {
    ...page,
    title: page.title || inferTitleFromContent(page.content),
  };

  /**
   * Infer title from content by checking frontmatter or first H1 header
   */
  function inferTitleFromContent(content: string): string | null {
    const trimmed = content.trim();
    if (trimmed.startsWith("---\n")) {
      const endIndex = trimmed.indexOf("\n---", 4);
      if (
        endIndex > 0 &&
        (endIndex + 4 === trimmed.length || trimmed[endIndex + 4] === "\n")
      ) {
        const frontmatterBlock = trimmed.slice(4, endIndex);
        const title = /(?:^|\n)\s*title\s*:\s*([^\n]+)/v.exec(
          frontmatterBlock,
        )?.[1];
        if (title) return title.trim();
      }
    }

    for (const line of stringToLines(content)) {
      const title = extractH1Title(line);
      if (title) return title;
    }
    return null;
  }
}

/**
 * Parses the entire string synchronously and returns an iterable of pages
 *
 * Automatically detects the format of the content by examining structure:
 * - VitePress plugin format: Pages separated by frontmatter metadata blocks
 * - Mintlify format: Pages with markdown headers followed by `Source: URL`
 * - Doc tag format: Pages wrapped in `<doc title="...">...</doc>` tags
 * - Page tag format: Pages wrapped in `<page>...</page>` tags
 * - H1 header format: Pages separated by H1 headers (`# Title`)
 *
 * @param content - The full content string of llms-full.txt
 * @returns A generator yielding Page objects
 *
 * @example
 * ```typescript
 * import { unbind } from "llms-full-unbind";
 *
 * const response = await fetch("https://example.com/llms-full.txt");
 * const text = await response.text();
 * const pages = Array.from(unbind(text));
 *
 * console.log(`Extracted ${pages.length} pages.`);
 * ```
 */
export function* unbind(content: string): Iterable<Page> {
  yield* processLines(stringToLines(content));
}

/**
 * Parses content from a Web ReadableStream or AsyncIterable and yields pages
 *
 * Accepts a standard Web `ReadableStream` (returned by `fetch`) or any AsyncIterable.
 * Yields pages as soon as they are parsed, making it ideal for streaming large files.
 *
 * Automatically detects the format of the content by examining structure:
 * - VitePress plugin format: Pages separated by frontmatter metadata blocks
 * - Mintlify format: Pages with markdown headers followed by `Source: URL`
 * - Doc tag format: Pages wrapped in `<doc title="...">...</doc>` tags
 * - Page tag format: Pages wrapped in `<page>...</page>` tags
 * - H1 header format: Pages separated by H1 headers (`# Title`)
 *
 * @param stream - A Web ReadableStream or AsyncIterable providing content chunks
 * @returns An async generator yielding Page objects
 *
 * @example
 * ```typescript
 * import { unbindStream } from "llms-full-unbind";
 *
 * const response = await fetch("https://example.com/llms-full.txt");
 *
 * if (!response.body) {
 *   throw new Error("Response body is empty");
 * }
 *
 * for await (const page of unbindStream(response.body)) {
 *   console.log(`Processed: ${page.title}`);
 * }
 * ```
 */
export async function* unbindStream(
  stream: ReadableStream<Uint8Array> | AsyncIterable<Uint8Array | string>,
): AsyncIterable<Page> {
  yield* processLinesAsync(toLines(stream));
}
