/**
 * llms_txt2ctx format parser
 *
 * Parses the llms_txt2ctx style format: `<doc title="..." desc="...">content</doc>`
 * Generated by the `llms_txt2ctx` CLI from the llms-txt package (https://github.com/AnswerDotAI/llms-txt).
 * Used by fastht.ml and similar projects.
 */

import type { Page, StreamingParser } from "./types.ts";

// Regular expression to match doc tags
// Matches <doc title="..." desc="...">content</doc>
const LLMS_TXT2CTX_DOC_REGEX =
  /<doc\s+title="(?<title>[^"]*)"(?:\s+desc="(?<desc>[^"]*)")?[^>]*>(?<content>[\s\S]*?)<\/doc>/g;

/**
 * Parse metadata from the content if present
 */
function parseMetadata(
  _content: string,
  desc?: string,
): Record<string, unknown> | undefined {
  const metadata: Record<string, unknown> = {};

  if (desc) {
    metadata.description = desc;
  }

  return Object.keys(metadata).length > 0 ? metadata : undefined;
}

/**
 * Parse a doc opening tag and extract attributes
 */
function parseDocTagAttributes(
  tag: string,
): { title: string; desc?: string } | null {
  const titleMatch = /title="([^"]*)"/.exec(tag);
  const descMatch = /desc="([^"]*)"/.exec(tag);

  if (!titleMatch) {
    return null;
  }

  return {
    title: titleMatch[1],
    desc: descMatch?.[1],
  };
}

/**
 * Parse llms_txt2ctx format content synchronously
 */
export function parseLlmsTxt2ctxFormat(content: string): Page[] {
  const pages: Page[] = [];

  // Reset regex lastIndex for fresh matching
  LLMS_TXT2CTX_DOC_REGEX.lastIndex = 0;

  let match: RegExpExecArray | null;
  while ((match = LLMS_TXT2CTX_DOC_REGEX.exec(content)) !== null) {
    const { title, desc, content: docContent } = match.groups!;

    const metadata = parseMetadata(docContent, desc);

    pages.push({
      title: title || "",
      content: docContent.trim(),
      ...(metadata && { metadata }),
    });
  }

  return pages;
}

/**
 * State machine states for streaming parser
 */
const PARSE_STATE = {
  LOOKING_FOR_DOC_START: 0,
  READING_DOC_TAG: 1,
  READING_CONTENT: 2,
} as const;
type ParseState = (typeof PARSE_STATE)[keyof typeof PARSE_STATE];

/**
 * Streaming parser for llms_txt2ctx format
 */
export class LlmsTxt2ctxStreamingParser implements StreamingParser {
  private buffer = "";

  private state: ParseState = PARSE_STATE.LOOKING_FOR_DOC_START;

  private currentTag = "";

  private tagDepth = 0;

  /**
   * Process the buffer and return complete pages
   */
  public *processBuffer(): Generator<Page> {
    while (this.buffer.length > 0) {
      if (this.state === PARSE_STATE.LOOKING_FOR_DOC_START) {
        // Look for <doc start
        const docStartIndex = this.buffer.indexOf("<doc");
        if (docStartIndex === -1) {
          // No doc tag found, but keep potential partial tag at end
          if (
            this.buffer.endsWith("<") ||
            this.buffer.endsWith("<d") ||
            this.buffer.endsWith("<do")
          ) {
            break;
          }
          this.buffer = "";
          break;
        }

        // Move to the doc tag start
        this.buffer = this.buffer.slice(docStartIndex);
        this.state = PARSE_STATE.READING_DOC_TAG;
        this.currentTag = "";
        this.tagDepth = 0;
      }

      if (this.state === PARSE_STATE.READING_DOC_TAG) {
        // Find the end of the opening tag
        const tagEndIndex = this.buffer.indexOf(">");
        if (tagEndIndex === -1) {
          // Tag not complete yet
          break;
        }

        this.currentTag = this.buffer.slice(0, tagEndIndex + 1);
        this.buffer = this.buffer.slice(tagEndIndex + 1);
        this.state = PARSE_STATE.READING_CONTENT;
        this.tagDepth = 1;
      }

      if (this.state === PARSE_STATE.READING_CONTENT) {
        // Look for closing </doc> tag, handling nested tags
        let searchPos = 0;
        let foundEnd = false;

        while (searchPos < this.buffer.length) {
          const nextOpenDoc = this.buffer.indexOf("<doc", searchPos);
          const nextCloseDoc = this.buffer.indexOf("</doc>", searchPos);

          if (nextCloseDoc === -1) {
            // No closing tag found yet
            break;
          }

          if (nextOpenDoc !== -1 && nextOpenDoc < nextCloseDoc) {
            // Found nested <doc before </doc>
            // Check if it's a complete opening tag
            const openTagEnd = this.buffer.indexOf(">", nextOpenDoc);
            if (openTagEnd !== -1 && openTagEnd < nextCloseDoc) {
              this.tagDepth++;
              searchPos = openTagEnd + 1;
              continue;
            }
          }

          // Found </doc>
          this.tagDepth--;
          if (this.tagDepth === 0) {
            // This is our closing tag
            const currentContent = this.buffer.slice(0, nextCloseDoc);
            this.buffer = this.buffer.slice(nextCloseDoc + "</doc>".length);

            const parsed = parseDocTagAttributes(this.currentTag);
            if (parsed) {
              const metadata = parseMetadata(currentContent, parsed.desc);
              yield {
                title: parsed.title,
                content: currentContent.trim(),
                ...(metadata && { metadata }),
              };
            }

            this.state = PARSE_STATE.LOOKING_FOR_DOC_START;
            foundEnd = true;
            break;
          }
          searchPos = nextCloseDoc + "</doc>".length;
        }

        if (!foundEnd) {
          // Need more data
          break;
        }
      }
    }
  }

  /**
   * Append data to the buffer
   */
  public append(data: string): void {
    this.buffer += data;
  }
}
