/**
 * Mintlify format parser
 *
 * Parses the format generated by Mintlify
 * Each page starts with "# Title" followed by "Source: URL"
 * https://www.mintlify.com/docs/ai/llmstxt
 */

import type { Page, StreamingParser } from "./types.ts";

/**
 * Regular expression to match H1 headers
 */
const H1_HEADER_REGEX = /^# (.+)$/;

/**
 * Extract title from H1 header line
 */
function extractTitle(line: string): string {
  const match = H1_HEADER_REGEX.exec(line);
  return match ? match[1].trim() : "";
}

/**
 * Extract source URL from content
 */
function extractSource(content: string): string | null {
  const lines = content.split("\n");
  // Source should be in the first few lines after the title
  for (let i = 0; i < Math.min(5, lines.length); i++) {
    const line = lines[i].trim();
    if (line.startsWith("Source:")) {
      return line.slice(7).trim();
    }
  }
  return null;
}

/**
 * Parse a single page section
 */
export function parseMintlifyPage(pageContent: string): Page | null {
  const trimmed = pageContent.trim();
  if (!trimmed) {
    return null;
  }

  // Extract title from the first line
  const lines = trimmed.split("\n");
  const firstLine = lines[0].trim();

  if (!firstLine.startsWith("# ")) {
    // If no H1 header, still try to create a page
    return {
      title: "",
      content: trimmed,
    };
  }

  const title = extractTitle(firstLine);

  // Extract source URL metadata
  const metadata: Record<string, unknown> = {};
  const source = extractSource(trimmed);
  if (source) {
    metadata.source = source;
  }

  return {
    title,
    content: trimmed,
    ...(Object.keys(metadata).length > 0 && { metadata }),
  };
}

/**
 * Parse mintlify format content synchronously
 */
export function parseMintlifyFormat(content: string): Page[] {
  const pages: Page[] = [];

  // Split content by H1 headers
  // We need to keep the header with the content
  const sections: string[] = [];
  let currentSection = "";
  const lines = content.split("\n");

  for (const line of lines) {
    if (line.startsWith("# ") && currentSection.trim()) {
      // Found a new page header, save the current section
      sections.push(currentSection);
      currentSection = `${line}\n`;
    } else {
      currentSection = `${currentSection}${line}\n`;
    }
  }

  // Don't forget the last section
  if (currentSection.trim()) {
    sections.push(currentSection);
  }

  for (const section of sections) {
    const page = parseMintlifyPage(section);
    if (page && (page.title || page.content)) {
      pages.push(page);
    }
  }

  return pages;
}

/**
 * Streaming parser for mintlify format
 */
export class MintlifyStreamingParser implements StreamingParser {
  private buffer = "";

  private currentSection = "";

  /**
   * Process the buffer and return complete pages
   */
  public *processBuffer(): Generator<Page> {
    // Add buffer to current section
    this.currentSection += this.buffer;
    this.buffer = "";

    // Process line by line looking for new page headers
    const lines = this.currentSection.split("\n");
    let processedUpTo = 0;
    let pendingSection = "";

    for (let i = 0; i < lines.length - 1; i++) {
      // Keep at least the last line in buffer
      const line = lines[i];

      if (line.startsWith("# ") && pendingSection.trim()) {
        // Found a new page header, yield the pending section
        const page = parseMintlifyPage(pendingSection);
        if (page && (page.title || page.content)) {
          yield page;
        }
        pendingSection = `${line}\n`;
        processedUpTo = i + 1;
      } else {
        pendingSection = `${pendingSection}${line}\n`;
        processedUpTo = i + 1;
      }
    }

    // Keep the pending section and the last (possibly incomplete) line
    if (processedUpTo < lines.length) {
      this.currentSection = pendingSection + lines[processedUpTo];
    } else {
      this.currentSection = pendingSection;
    }
  }

  /**
   * Process final content in buffer
   */
  public *flush(): Generator<Page> {
    if (this.currentSection.trim()) {
      const page = parseMintlifyPage(this.currentSection);
      if (page && (page.title || page.content)) {
        yield page;
      }
    }
  }

  /**
   * Append data to the buffer
   */
  public append(data: string): void {
    this.buffer += data;
  }
}
